<template>
  <validation-observer ref="observer">
    <v-form @submit.prevent="submit">
      <!-- TITLE FIELD -->
      <validation-provider v-slot="{ errors }" name="Title" rules="required">
        <v-text-field
          v-model="title"
          :error-messages="errors"
          label="Title"
          required
          outlined
        ></v-text-field>
      </validation-provider>
      <!-- DESC FIELD -->
      <validation-provider v-slot="{ errors }" name="Description" rules="required">
        <v-textarea
          v-model="description"
          :error-messages="errors"
          label="Description"
          required
          outlined
        ></v-textarea>
      </validation-provider>
      <!-- AUTHOR FIELD -->
      <validation-provider v-slot="{ errors }" name="Author" rules="required">
        <v-text-field
          v-model="author"
          :error-messages="errors"
          label="Author"
          required
          outlined
        ></v-text-field>
      </validation-provider>
      <!-- ARTIST FIELD -->
      <validation-provider v-slot="{ errors }" name="Artist" rules="required">
        <v-text-field
          v-model="artist"
          :error-messages="errors"
          label="Artist"
          required
          outlined
        ></v-text-field>
      </validation-provider>
      <!-- YEAR FIELD -->
      <validation-provider
        v-slot="{ errors }"
        name="Year of release"
        :rules="{
          digits: 4,
        }"
      >
        <v-text-field
          v-model="year"
          :error-messages="errors"
          label="Year of release"
          required
          outlined
        ></v-text-field>
      </validation-provider>
      <!-- STATUS FIELD -->
      <validation-provider v-slot="{ errors }" name="Status" rules="required">
        <v-select
          :items="statusItems"
          v-model="status"
          :error-messages="errors"
          label="Status"
          outlined
        ></v-select>
      </validation-provider>
      <!-- COVER FIELD -->
      <validation-provider v-slot="{ errors }" name="Cover" :rules="manga ? '' : 'required'">
        <v-file-input v-model="cover" :error-messages="errors" accept="image/*" label="Cover">
        </v-file-input>
      </validation-provider>
      <!-- PREVIEW -->
      <v-expansion-panels class="mb-4">
        <v-expansion-panel>
          <v-expansion-panel-header> Preview </v-expansion-panel-header>
          <v-expansion-panel-content>
            <manga-row :loading="false" :manga="params" :cover="url(cover) || ''" />
          </v-expansion-panel-content>
        </v-expansion-panel>
      </v-expansion-panels>
      <div class="text-center">
        <v-btn type="submit" block color="background" class="text--primary">
          {{ manga ? 'Edit Manga' : 'Create Manga' }}
        </v-btn>
      </div>
    </v-form>
  </validation-observer>
</template>

<script lang="ts">
import { Vue, Component, Prop } from 'vue-property-decorator';
import { required, digits } from 'vee-validate/dist/rules';
import { extend, ValidationProvider, setInteractionMode, ValidationObserver } from 'vee-validate';
import MangaRow from '@/components/MangaRow.vue';
import Manga from '@/api/Manga';
import Media from '@/api/Media';
import type { AxiosRequestConfig } from 'axios';
import type { MangaResponse, MangaSchema, Status } from '@/api/Manga';

setInteractionMode('eager');

extend('required', {
  ...required,
  message: '{_field_} can not be empty',
});
extend('digits', {
  ...digits,
  message: '{_field_} requires {length} digits ',
});

@Component({
  components: {
    MangaRow,
    ValidationProvider,
    ValidationObserver,
  },
})
export default class MangaForm extends Vue {
  @Prop() readonly manga!: MangaResponse | null;

  title = '';

  description = '';

  author = '';

  artist = '';

  year?: number | null = null;

  status: Status | null = null;

  cover: File | null = null;

  buffer = null;

  statusItems = [
    { value: 'ongoing', text: 'Ongoing' },
    { value: 'hiatus', text: 'Hiatus' },
    { value: 'completed', text: 'Completed' },
    { value: 'cancelled', text: 'Cancelled' },
  ];

  get params(): MangaSchema {
    return {
      title: this.title,
      description: this.description,
      author: this.author,
      artist: this.artist,
      year: this.year ?? undefined,
      status: this.status ?? 'ongoing',
    };
  }

  get authConfig(): AxiosRequestConfig {
    return this.$store.getters.authConfig;
  }

  url(blob: File | null): string | null {
    if (blob) {
      return blob ? URL.createObjectURL(blob) : null;
    } else {
      return this.manga ? Media.cover(this.manga.id, this.manga.version) : null;
    }
  }

  async submit(): Promise<void> {
    //@ts-expect-error I can't define this $ref, so let's assume it works
    const valid = await this.$refs.observer.validate();
    if (valid) {
      if (this.manga) {
        await this.editManga(this.params, this.manga.id);
      } else {
        await this.createManga(this.params);
      }
    }
  }

  clear(): void {
    this.title = '';
    this.description = '';
    this.author = '';
    this.artist = '';
    this.year = null;
    this.status = null;
  }

  async createManga(params: MangaSchema): Promise<void> {
    const response = await Manga.create(params, this.authConfig);

    if (response.data) {
      await this.setCover(response.data.id, this.cover);
    } else {
      const notification = {
        context: 'Create manga',
        message: response.error ?? '',
        color: 'error',
      };
      await this.$store.dispatch('pushNotification', notification);
    }
    if (response.status === 401) {
      this.$store.commit('logout');
    }
  }

  async editManga(params: MangaSchema, id: string): Promise<void> {
    const response = await Manga.edit(id, params, this.authConfig);

    if (response.data) {
      if (this.cover) {
        await this.setCover(id, this.cover);
      } else {
        await this.$router.push(`/manga/${id}`);
      }
    } else {
      const notification = {
        context: 'Edit manga',
        message: response.error ?? '',
        color: 'error',
      };
      await this.$store.dispatch('pushNotification', notification);
    }
    if (response.status === 401) {
      this.$store.commit('logout');
    }
  }

  async setCover(mangaId: string, cover: File | null): Promise<void> {
    if (!cover) {
      return;
    }

    const response = await Manga.setCover(mangaId, cover, this.authConfig);

    if (response.data) {
      await this.$router.push(`/manga/${mangaId}`);
    } else {
      const notification = {
        context: 'Set cover',
        message: response.error ?? '',
        color: 'error',
      };
      await this.$store.dispatch('pushNotification', notification);
    }
    if (response.status === 401) {
      this.$store.commit('logout');
    }
  }

  mounted(): void {
    if (this.manga) {
      this.title = this.manga.title;
      this.description = this.manga.description;
      this.author = this.manga.author;
      this.artist = this.manga.artist;
      this.year = this.manga.year;
      this.status = this.manga.status;
    }
  }
}
</script>
